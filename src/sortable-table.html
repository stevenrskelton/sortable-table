<!--
 https://github.com/stevenrskelton/sortable-table
-->
<polymer-element name="sortable-table" attributes="data columns sortColumn sortDescending">
	<template>
		<table class="ssDatatable">
			<tr on-click="{{changeSort}}">
			  <template repeat="{{column in columns}}">
				<template ref="{{column.headerTemplate}}" bind>
				  <th style="{{sortColumn==column.name && sortDescending ? 'text-decoration:overline;' : ''}}
				  {{sortColumn==column.name && !sortDescending ? 'text-decoration:underline;' : ''}}">{{!(column.title) ? column.name : column.title}}</th>
				</template>
			  </template>
			</tr>
			<template repeat="{{row in data | sortByKey(sortColumn, sortDescending, columns)}}">
			  <tr>
				<template repeat="{{column in columns}}">
				  <template bind="{{templateData in row | computeTemplateData(column)}}">
					<template ref="{{column.cellTemplate}}" bind="{{templateData}}">
						<td>{{value}}</td>
					</template>
				  </template>
				</template>
			  </tr>
			</template>
			<template if="{{showFooter}}">
			  <tr>
				<template repeat="{{column in columns}}">
				  <template bind="{{values in data | selectProperty(column)}}">
					<template ref="{{column.footerTemplate}}" bind>
						<td class="ssDatatableHeader" style="border:0;"></td>
					</template>
				  </template>
				</template>
			  </tr>
			</template>
		</table>
	</template>

	<script>
	  PolymerExpressions.prototype.sortByKey = function(array, key, desc, columns) {
		return array.sort(function(a, b) {
		  var x, y;
		  //determine if computed field
		  var formula = null;
		  for(var i=0;i<columns.length;i++){
			if(columns[i].name===key){
				formula = columns[i].formula;
				break;
			}
		  }
		  if(formula){
			x = formula(a);
			y = formula(b);
		  }else{
			x = a[key];
			y = b[key];
		  }

		  if(typeof x == 'undefined' || typeof y == 'undefined'){
			//sort undefined after
			if(typeof x == 'undefined'){
			  return !desc;
			}else{
			  return desc;
			}
		  }else{
			if (typeof x == "string" && typeof y == "string"){
			  x = x.toLowerCase();
			  y = y.toLowerCase();
			}
			if(desc){
			  return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			}else{
			  return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			}
		  }
		});
	  };
	  PolymerExpressions.prototype.computeTemplateData = function(row, column) {
		var value;
		if(column.formula){
		  value = column.formula(row);
		}else{
		  value = row[column.name];
		}
		return { row: row, value: value };
	  };
	  PolymerExpressions.prototype.selectProperty = function(objects, column) {
		var arr = [];
		for(var i=0;i<objects.length;i++){
		  var row = objects[i];
		  var value;
		  if(column.formula){
			value = column.formula(row);
		  }else{
			value = row[column.name];
		  }
		  arr.push(value);
		}
		return arr;
	  };  
	  PolymerExpressions.prototype.sum = function(arr) {
		return arr.reduce(function(a, b) { return a + b; }, 0);
	  };
	  PolymerExpressions.prototype.average = function(arr) {
		if(arr.length==0){
		  return 0;
		}else{
		  return arr.reduce(function(a, b) { return a + b; }, 0) / arr.length;
		}
	  };
	  Polymer('sortable-table', {
		  data: [],
		  columns: null,
		  sortColumn: null,
		  sortDescending: false,
		  changeSort: function(e,p,o){
			var clickedSortColumn = e.target.templateInstance_.model.column.name;
			if(clickedSortColumn == this.sortColumn){
			  //column already sorted, reverse sort
			  this.sortDescending = !this.sortDescending;
			}else{
			  this.sortColumn = clickedSortColumn;
			}
		  },
		  importedTemplates: [],
		  showFooter: false,
		  columnsChanged: function(){
			var self = this;
			function addTemplateIfNotInDocument(templateId){
			  if(templateId && !self.shadowRoot.getElementById(templateId)){
				var t = self.ownerDocument.getElementById(templateId);
				if(t){
				  self.shadowRoot.appendChild(t);
				  self.importedTemplates.push(t);
				}else{
				  //TODO: in some cases on refresh, template isn't in self.ownerDocument.
				  //So store them in an importedTemplates array :(
				  for(var i=0;i<self.importedTemplates.length;i++){
					self.shadowRoot.appendChild(self.importedTemplates[i]);
				  }
				}
			  }
			}
			  
			for(var i=0;i<this.columns.length;i++){
			  addTemplateIfNotInDocument(this.columns[i].cellTemplate);
			  addTemplateIfNotInDocument(this.columns[i].headerTemplate);
			  addTemplateIfNotInDocument(this.columns[i].footerTemplate);
			  if(this.columns[i].footerTemplate) this.showFooter=true;
			}
		  },
		  dataChanged: function(){
			if(this.columns==null && this.data!=null && this.data.length > 0){
			  var c = [];
			  var o = this.data[0];
			  for (var key in o) {
				if (o.hasOwnProperty(key)) {
				  c.push({name: key});
				}
			  }
			  this.columns = c;
			}
		  }
	  });
	</script>
	<style>
	  table.ssDatatable {
		width: 100%;
		border-collapse: collapse;
	  }
	  table.ssDatatable tr:nth-of-type(even) {
		background-color: rgba(255,255,224,0.25);
	  }
	  table.ssDatatable .ssDatatableHeader,
	  table.ssDatatable th {
		background: #555;
		color: white;
		font-weight: bold;
		text-align: center;
	  }
	  table.ssDatatable td,
	  table.ssDatatable th {
		padding: 6px;
		border: 1px solid #ccc;
		text-align: right;
	  }
	  table.ssDatatable th {
		text-align: center;
		cursor: pointer;
	  }
	  table.ssDatatable td:first-of-type {
		text-align: left;
	  }
	</style>
</polymer-element>
